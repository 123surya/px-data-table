<!--
//http://webcomponents.github.io/articles/web-components-best-practices/
-->
<!--
/**
 * @module aha-table
 *
 *
 * Searchable Sortable Editable Paginatable Data Table
 *
 * aha-table is an data table/grid, it cousumes a modal data
 * and modal meta to show a table that can search, sort, edit
 * in place and pagiation, click to edit.
 *
 * Examples:
 *
 *     <aha-table></aha-table>
 *
 *     <aha-table id="raw"
 *         selectable
 *         copyable
 *         removable
 *         movable
 *         seachable
 *         pagesize="20"
 *         pagesizetitle="Page Size:"
 *         summarytitle="Viewing">
 *         < name="title"
 *             type="string"
 *             label="My Title"
 *             sortable
 *             searchable
 *             required
 *             editable
 *             placeholder="Example text"
 *             default=""
 *             hint="Meaning title will help you remember">
 *         </>
 *     </aha-table/>
 *
 * Available Event Hander:
 *     after-invalid(Object detail)
 *     px-row-click(Object detail)
 *     after-td-dbclick(Object detail)
 *     after-create(Object new_record)
 *     after-copy(Object new_record)
 *     after-save(Object new_record)
 *     after-select(Object new_record)
 *     after-remove(Object removed_record)
 *     after-move-down(Object moved_record)
 *     after-move-up(Object moved_record)
 *
 * @class aha-table
 * Based on https://github.com/liuwenchao/aha-table
 *
 */
-->

<link rel="import" href="../polymer/polymer.html">

<dom-module id="aha-table">
	<link rel="import" type="css" href="css/aha-table.css" />
	<template>
	<div class="scroll-body">
		<div class$="{{getTableClass(tableRows, tableColumns)}}" id="aha_table_main" unresolved="">
			<span class="tr">
				<template is="dom-if" if="{{selectable}}">
					<span class="th">
						<div>
							Selected
						</div>
						<div
							title$="{{searchtitle}}"
							hidden$="{{!searchable}}"
							class="filterrow search"
							on-click="toggleFilters"></div>
					</span>
				</template>
				<template is="dom-repeat" items="{{meta}}" as="column">
					<span
						title$="{{columntitle}}"
						class$="{{getHeaderClass(column)}}">
						<span
							class$="{{getTextSortingClass(column, sortedColumn)}}"
							title$="{{sorttitle}}"
							on-click="sort">{{column.label}}<i class$="{{getSortingClass(column, sortedColumn, descending)}}"></i>
						</span>
						<span
							hidden$="{{!column.hint}}"
							class=" hint"
							title$="{{column.hint}}"></span>
					</span>
				</template>
			</span>
			<span class$="{{getFilterClass(searchable)}}" id="filter">
				<template is="dom-if" if="{{selectable}}">
					<span class="td filter--cell">
						<div class="flex flex--center">
							<input type="checkbox"
								on-change="selectall"
								title$="{{selectalltitle}}"
								hidden$="{{!selectable}}"/>
						</div>
					</span>
				</template>
				<template is="dom-repeat" items="{{meta}}" as="column">
					<span class="td filter--cell">

						<template is="dom-if" if="{{column.searchable}}">
							<template is="dom-if" if="{{isEqual(column.type, 'choice')}}">
								<select class="filter-input" on-change="search">
										<template is="dom-repeat" items="{{column.options}}" as="option">
											<option value$="{{option.value}}">{{option.label}}</option>
										</template>
								</select>
							</template>
							<template is="dom-if" if="{{isEqual(column.type, 'boolean')}}">
								<div class="flex">
									<input class="filter-input text-input--bare" type="text" title$="{{column.hint}}" on-keyup="search"/>
						      <i class="fa fa-filter"></i>
						    </div>
							</template>

							<template is="dom-if" if="{{isTextType(column.type)}}">
								<div class="flex">
						      <input class="filter-input text-input--bare" type="text" on-keyup="search" placeholder$="{{column.searchplaceholder}}"/>
						      <i class="fa fa-filter"></i>
						    </div>
							</template>
						</template>
					</span>
				</template>
			</span>
			<template id="recordList" is="dom-repeat" items="{{viewingRows}}" as="row">
				<span class$="{{getRowClass(row, selectedRows.splices)}}" on-click="click">
					<template is="dom-if" if="{{selectable}}">
						<span  class="td">
							<div class="flex flex--center">
								<input type="checkbox"
									class="js-table__select-checkbox"
									title$="{{selecttitle}}"
									hidden$="{{!selectable}}"
									/>
								</div>
						</span>
					</template>

					<template is="dom-repeat" items="{{meta}}" as="column">
						<span
							on-dblclick="dbclick"
							title="{{getEditTitle(column.editable, edittitle)}}"
							class$="{{getCellClass(column.name)}}">
							<div hidden>
								<template is="dom-if" if="{{isEqual(column.type, 'choice')}}">
									<select
										required$="{{column.required}}"
										on-blur="save">
										<template is="dom-repeat" items="{{column.options}}" as="option">
											<option
												selected$="{{isOptionSelected(option.value, row, column.name)}}"
												value="{{option.value}}">{{option.label}}</option>
										</template>
									</select>
								</template>
								<template is="dom-if" if="{{isEqual(column.type, 'string')}}">
									<input type="text"
										required$="{{column.required}}"
										on-blur="save"
										value$="{{getValue(row,column.name)}}"/>
								</template>
								<template is="dom-if" if="{{isEqual(column.type, 'date')}}">
									<input type="date"
										required?="{{column.required}}"
										on-blur="save"
										value$="{{getValue(row,column.name)}}"/>
								</template>
								<template is="dom-if" if="{{isEqual(column.type, 'time')}}">
									<input type="time"
										required?="{{column.required}}"
										on-blur="save"
										value$="{{getValue(row,column.name)}}"/>
								</template>
								<template is="dom-if" if="{{isEqual(column.type, 'datetime')}}">
									<input type="datetime"
										required?="{{column.required}}"
										on-blur="save"
										value$="{{getValue(row,column.name)}}"/>
								</template>
								<template is="dom-if" if="{{isEqual(column.type, 'text')}}">
									<textarea
										required?="{{column.required}}"
										on-blur="save">{{getValue(row,column.name)}}</textarea>
								</template>
								<template is="dom-if" if="{{isEqual(column.type, 'boolean')}}">
									<input type="checkbox"
										on-change="save"
										on-blur="save"
										checked$="{{getValue(row,column.name)}}" />
								</template>
							</div>
	            <div

								class$="{{getReaderClass(row, column.name)}}">
	                <template is="dom-if" if="{{!isEqual(column.type, 'html')}}">
	                  <span>{{readContent(row, column)}}</span>
	                </template>
	                <template is="dom-if" if="{{isEqual(column.type, 'html')}}">
	                  <aha-html-echo html="{{readContent(row, column)}}"></aha-html-echo>
	                </template>
	            </div>
						</span>
					</template>
				</span>
			</template>

		</div>
	</div>

		<div style="float: right;" class="pagination">
			<span class="pagesize">
				<span class="u-mr--">{{pagesizetitle}}</span>
				<select on-change="changeDropDown">
						<option>5</option>
						<option selected>10</option>
						<option>20</option>
						<option>50</option>
						<option>100</option>
				</select>
			</span>
			<span class="u-pl+ u-ml+ summary">
				<span>{{summarytext}}</span>
				<span>{{firstItemIndex}}</span>-<span>{{lastItemIndex}}</span>
				<span>{{itemoftext}}</span>
				<span>{{itemCount}}</span>
			</span>
			<span class="paging">
				<template is="dom-if" if="{{showGotoFirstLast}}">
					<button
						title$="{{firsttitle}}"
						class$="{{getPageupClass(currentpage, 'btn btn--bare btn--pagination u-p- first')}}"
						on-click="firstPage"><i class="fa fa-angle-double-left"></i></button>
				</template>
				<button
					title$="{{previoustitle}}"
					class$="{{getPageupClass(currentpage, 'btn btn--bare btn--pagination u-p- previous')}}"
					on-click="prevPage"><i class="fa fa-angle-left"></i></button>
				<span class="pager">
					<template is="dom-repeat" items="{{pagerButtons(pageCount, currentpage)}}" as="page">
						<span on-click="gotoPage" class$="{{getPagerButtonClass(page.val, currentpage)}}">{{page.val}}</span>
					</template>
				</span>
				<button
					title$="{{nexttitle}}"
					class$="{{getPagedownClass(currentpage, pageCount, 'btn btn--bare btn--pagination u-p- next')}}"
					on-click="nextPage"><i class="fa fa-angle-right"></i></button>
				<template is="dom-if" if="{{showGotoFirstLast}}">
					<button
						title$="{{lasttitle}}"
						class$="{{getPagedownClass(currentpage, pageCount, 'btn btn--bare btn--pagination u-p- last')}}"
						on-click="lastPage"><i class="fa fa-angle-double-right"></i></button>
				</template>
			</span>
		</div>
	</template>
</dom-module>
<script>
	Polymer({
		is: 'aha-table',
		properties: {
			//data: instance of the model data
			data: {
				type: Array,
				value: function() { return []; },
				observer: 'dataChanged'
			},
			//meta: instance of the model meta
			meta: {
				type: Array,
				value: function() { return []; }
			},
			/**
			 * modified: all created or modified row will be referenced here.
			 * it's hard to determine if it's created or modified after multiple
			 * operations, because the element doesn't assume there's an id column,
			 * so you need to determine if by yourself, like check
			 * if the id exists if your model has an id column.
			 */
			modified: {
				type: Array,
				value: function() { return []; },
				observer: 'modifiedChanged'
			},
			//deleted: all deleted row will be moved here.
			deleted: {
				type: Array,
				value: function() { return []; }
			},
			//selected: all selected row will be referenced here.
			selectedRows: {
				type: Array,
				value: function(){
					return [];
				},
        notify: true,
        reflectToAttribute: true,
				observer: '_selectedRowsChanged'
			},
			//all visiable rows are reference here.
			viewingRow: {
				type: Array,
				value: function() { return []; }
			},
			//selectable: if table row is selectable
			selectable: {
				type: Boolean,
				value: false
			},
			//striped: if table row is striped
			striped: {
				type: Boolean,
				value: false
			},
			//tableRows: if table row is striped
			tableRows: {
				type: Boolean,
				value: false
			},
			//tableColumns: if table row is striped
			tableColumns: {
				type: Boolean,
				value: false
			},
			//copyable: if table row is copyable
			copyable: {
				type: Boolean,
				value: false
			},
			//removable: if table row is removable
			removable: {
				type: Boolean,
				value: false
			},
			//movable: if table row is movable
			movable: {
				type: Boolean,
				value: false
			},
			//searchable: if table row is searchable
			searchable: {
				type: Boolean,
				value: false,
				observer: "_searchableToggled"
			},
			// text displayed in first column of search row.
			searchtitle: {
				type: String,
				value: ""
			},
			// text displayed as title of select checkbox.
			selecttitle: {
				type: String,
				value: ""
			},
			// text displayed as title of sorting column.
			sorttitle: {
				type: String,
				value: ""
			},
			// text displayed as title of column name.
			columntitle: {
				type: String,
				value: ""
			},
			// text displayed as title of copy indicator.
			copytitle: {
				type: String,
				value: ""
			},
			// text displayed as title of remove checkbox..
			removetitle: {
				type: String,
				value: ""
			},
			// text displayed as title of move up indicator.
			moveuptitle: {
				type: String,
				value: ""
			},
			// text displayed as title of move down indicator.
			movedowntitle: {
				type: String,
				value: ""
			},
			// text displayed as title of editable cell.
			edittitle: {
				type: String,
				value: ""
			},
			//sortedColumn: sorted column name
			sortedColumn: {
				type: String,
				value: ""
			},
			//editingRow: current editing row
			//@type {Object}
			editingRow : {
				type: Object,
				value: function() { return {}; }
			},
			//if filtering has been performed.
			filtered: {
				type: Boolean,
				value: false
			},
			//editingRow: current rows in display/view
			viewingRows : {
				type: Array,
				value: function() { return []; }
			},
			//descending: current sorting order
			descending: {
				type: Boolean,
				value: false
			},
			//pagesize: the number of items to show per page
			pagesize: {
				type: Number,
				value: 10,
				observer: 'pagesizeChanged'
			},
			//currentpage: the current active page in view
			currentpage: {
				type: Number,
				value: 1,
				observer: 'currentpageChanged'
			},
			pageoftext: {
				type: String,
				value: "/"
			},
			itemoftext: {
				type: String,
				value: "of"
			},
			//pageCount: the number of paginated pages
			pageCount: {
				type: Number,
				value: 0
			},
			//itemCount: the number of visible items
			itemCount: {
				type: Number,
				value: 0
			},
			//firstItemIndex: the index number of first item in the page, start from 1
			firstItemIndex: {
				type: Number,
				value: 1
			},
			//lastItemIndex: the index number of last item in the page, start from 1
			lastItemIndex:  {
				type: Number,
				value: 1
			},
			//sizelist: range list to adjust page size.
			sizelist: {
				type: Array,
				value: function(){return [5, 10, 20, 50, 100];}
			},
			//pagesizetitle: label for page size box
			pagesizetitle: {
				type: String,
				value: "Rows per page"
			},
			//summarytitle: label for table summary area
			summarytitle: {
				type: String,
				value: ""
			},
			//show go-to first/last pagination buttons.
			showGotoFirstLast: {
				type: Boolean,
				value: false
			},
      // custom function declarations, used in individual columns for filtering/sorting
      customFunctions: {
        type: Object,
        value: {}
      }
		},

		ready: function() {
			if (this.get('meta').length === 0) {
				this.dataChanged(this.get('data'), []);
			}
			if (this.dataset && this.dataset.sizelist) {
				this.sizelist = JSON.parse(this.dataset.sizelist);
			}
			//Show element when it's ready.
			this.$.aha_table_main.setAttribute('resolved', '');
			this.$.aha_table_main.removeAttribute('unresolved');
		},
		getRowClass: function(row, selectedRows) {
			return ['tr', 'rows',
					this.striped  ? 'striped'  : '',
					row._modified ? 'modified' : '',
					row._editing  ? 'editing'  : '',
					(this.selectedRows.indexOf(row) > -1) ? 'selected'  : ''
				].join(' ');
		},
		isCheckboxSelected: function(selected) {
			if (typeof selected === "undefined" || selected === false) {
				return false;
			} else {
				return true;
			}
		},
		isEditing: function(rowEditable, columnEditable) {
			return rowEditable && columnEditable;
		},
		isNotEditing: function(rowEditable, columnEditable) {
			return !rowEditable || !columnEditable;
		},
		getReaderClass: function(row, columnName) {
			var datum = row[columnName], classList = ['viewing'];
			if (datum === null || datum === undefined
				|| typeof datum === 'string' && datum.trim().length === 0) {
				classList.push('empty');
			}
			return classList.join(' ');
		},
		readContent: function(row, column) {
			var datum = row[column.name];
			if (datum === null || datum === undefined
				|| typeof datum === 'string' && datum.trim().length === 0) {
					var options = column.options;
					var blank = column.placeholder;
					if (datum !== "" && options) {
					//translate value to labels for select
						for (var i = options.length - 1; i >= 0; i--) {
							if (options[i].value === datum) {
								return options[i].label;
							}
						}
					}
					datum = datum === undefined || datum === null ? '' : datum;
					return datum === "" ? blank : datum;
			} else {
				if (column['max-column-character-width'] > 0){
					datum = this._clipDatumString(datum, column);
				}
				return datum;
			}
		},
		_clipDatumString: function(datum, column){
			var colWidth = column['max-column-character-width'];
			if (datum.length > colWidth){
				if (column['ellipsis-clip-position'] === 'left') {
					datum = '\u2026' + datum.substr(datum.length - colWidth, datum.length);
				}
				else if (column['ellipsis-clip-position'] === 'center') {
					var datumLeftIndex = Math.floor(colWidth/2),
							datumRightIndex = colWidth - datumLeftIndex;
					datum = datum.substr(0, datumLeftIndex) + '\u2026' + datum.substr(datum.length - datumRightIndex, datum.length);
				}
				else { //assume right
					datum = datum.substr(0, colWidth) + '\u2026';
				}
			}
			return datum;
		},
		getColspan: function(metaLength) {
			return metaLength + 1;
		},
		isEqual: function(source, target) {
			return source === target;
		},
		isOptionSelected: function(optionValue, row, column_name) {
			return optionValue === row[column_name];
		},
		getPageupClass: function(currentPage, additionalClass) {
			return [currentPage === 1 ? "btn--disabled" : "", additionalClass].join(' ');
		},
		getPagedownClass: function(currentPage, pageCount, additionalClass) {
			return [pageCount <= 0 || currentPage === pageCount ? "btn--disabled" : "", additionalClass].join(' ');
		},
		getEditTitle: function(editable, editTitle) {
			return editable ? editTitle : '';
		},
		getHeaderClass: function(item) {
      return ['th ', 'aha-', item.name, '-th'].join('') + (item.sortable ? ' sortable' : '');
		},
		getFilterClass: function(searchable) {
			var classList = ['tr'];
			if(!searchable){
				classList.push('hidden');
			}
			return classList.join(' ');
		},
		getPagerButtonClass: function(buttonValue, currentPage){
			var classList = ['btn'];
			if (buttonValue === currentPage){
				classList.push('btn--icon', 'u-ml0', 'btn--pagination--number');
			}else{
				classList.push('btn--bare', 'u-ml0', 'btn--bare__pagination');
			}
			return classList.join(' ');
		},
		getSortingClass: function(column, sortingColumn, descending) {
			var classList = ['u-ml-', 'sorting', 'fa'];
			if (sortingColumn === column.name) {
				classList.push(descending ? 'fa-caret-down' : 'fa-caret-up');
			}
			return classList.join(' ');
		},
		getTextSortingClass: function(column, sortingColumn) {
			var classList = ['column-head'];
			if (sortingColumn === column.name) {
				classList.push('sorted-text');
			}
			return classList.join(' ');
		},
		getCellClass: function(name) {
			return ['td ', 'aha-', name, '-td'].join('');
		},
		getTableClass: function(tableRows, tableColumns){
			var classList= ['table', 'table--small'];
			if (tableRows){
				classList.push('table--rows');
			}
			if (tableColumns){
				classList.push('table--columns');
			}
			return classList.join(' ');
		},
		isTextType: function(type) {
			return type !== 'choice' && type !== 'boolean';
		},
		getValue: function(row, name) {
			return row[name];
		},

		//=============
		//internal methods
		dataChanged: function(newValue, oldValue) {
			if (!this.meta || this.meta.length === 0)  {
				this.$.aha_table_main.setAttribute('unresolved', '');
				// generate meta from data if meta is not provided from px-data-table-column.
				var meta = [];
				for (var prop in this.data[0]) {
					if (prop.indexOf('_') !== 0) {//skip internal field
						meta.push({
							name: prop,
							label: prop.charAt(0).toUpperCase() + prop.slice(1),
							type: [true, false].indexOf(this.data[0][prop]) > -1 ? "boolean" : "string",
							sortable: true,
							searchable: true,
							editable: false,
							required: false
						});
					}
				}
				for (var i = 0; i < this.data.length; i++) {
					this.set('_editing',  false, this.data[i]);
					this.set('_modified', false, this.data[i]);
					this.set('_filtered', false, this.data[i]);
				}
				this.set('meta', meta, this);
				this.$.aha_table_main.setAttribute('resolved', '');
				this.$.aha_table_main.removeAttribute('unresolved');
			}
			this.refreshPagination(true);
		},
		modifiedChanged: function() {},
		edit: function(e) {
			var row = e.model.row;
			this.set('_editing', true, row);
			if (this.editingRow && this.editingRow !== row) {
				this.set('_editing', false, this.editingRow);
			}
			this.set('editingRow', row);
			e.target.setAttribute('hidden', true);
			e.target.previousElementSibling.removeAttribute('hidden');
			Polymer.dom(e.target.previousElementSibling).querySelector('input,select,textarea').focus();
		},
		save: function(e) {
			var row = e.model.row,
					column = e.model.column,
					editor,
					reader;
			if(row){
				this.fire('before-save', {"event": e, "row" : row, "column" : column});
				if ("CHECKBOX" === e.target.type.toUpperCase()) {
					this.set(column.name, e.target.checked, row);
				} else {
					this.set(column.name, e.target.value,   row);
				}
				if (this.modified.indexOf(row) === -1) {
					this.set('_modified', true, row);
					this.push('modified', row);
				}

				if (!e.relatedTarget
					|| !e.relatedTarget.templateInstance
					|| e.relatedmodel.row !== e.model.row) {
					this.set('_editing', false, row);

					editor = e.target.parentElement;
					reader = editor.nextElementSibling;
					editor.setAttribute('hidden', true);
					reader.removeAttribute('hidden');
					reader.innerText = this.readContent(row, column);
					if (row[column.name] !== undefined && row[column.name] !== '') {
						reader.classList.remove('empty');
					} else {
						reader.classList.add('empty');
					}
				}

				if (column.required && !e.target.validity.valid) {
					this.fire('after-invalid', {"event": e, "row" : row, "column" : column});
				}
				this.fire('after-save', {"event": e, "row" : row, "column" : column});
			}
		},
		sort: function(e, p) {
			var column = e.model.column;
			if(column && column.sortable){
				var sortingColumn = column.name;
				if (sortingColumn === this.sortedColumn){
					this.set('descending', !this.descending);
				} else {
					this.set('sortedColumn', sortingColumn);
				}
			}

			this.refreshPagination();
		},
		unsort: function() {
			this.set('sortedColumn', "");
			this.refreshPagination();
		},
		search: function(e, p) {
			if(e.model.column){
				var searchedColumn = e.model.column.name,
				i,
				len, data = this.data;

				for (i = 0,len=data.length; i < len; i++) {
					var matched = false;
					data[i]._not_matched_columns = data[i]._not_matched_columns || [];

					var customSearchFunction = this.customFunctions[e.model.column['filter-function-name']];
					if (customSearchFunction) {
						matched = customSearchFunction(e.target.value, data[i][searchedColumn]);
					}
					//checkbox will only filter checked data[i]s.
					else {
						if ("CHECKBOX" === e.target.type.toUpperCase()) {
							matched = !e.target.checked || data[i][searchedColumn];
						} else if (
							// empty search means it always match
							e.target.value === ""
							||
							// non-empty search and the content matches.
							data[i][searchedColumn].toString()
							&& data[i][searchedColumn].toString().toLowerCase().indexOf(e.target.value.toString().toLowerCase()) > -1) {
							matched = true;
						}
					}

					if (matched) {
						if (data[i]._not_matched_columns.indexOf(searchedColumn) > -1) {
							// then we remove matched column from _not_matched_columns list.
							data[i]._not_matched_columns.splice(data[i]._not_matched_columns.indexOf(searchedColumn), 1);
						}
						// update _filtered state
						// true if there's other not-matched_column
						// false if all column matches.
						data[i]._filtered = data[i]._not_matched_columns.length > 0;
					} else {
						// Not matched!
						data[i]._filtered = true;
						if (data[i]._not_matched_columns.indexOf(searchedColumn) === -1) {
							data[i]._not_matched_columns.push(searchedColumn);
						}
					}
				}

				this.filtered = this.data.some(function(row){return row._filtered;});
				this.refreshPagination();
			}
		},

		//==================
		//pagination
		firstPage: function() {
			this.currentpage = 1;
		},
		prevPage: function() {
			if ( this.currentpage > 1 ) {
				this.currentpage--;
			}
		},
		nextPage: function() {
			if ( this.currentpage < this.pageCount ) {
				this.currentpage++;
			}
		},
		lastPage: function() {
			this.currentpage = this.pageCount;
		},
		currentpageChanged: function(){
			this.filterPage();
			this.updateFirstAndLastDisplayedItemIndexes();
		},
		updateFirstAndLastDisplayedItemIndexes: function() {
			this.firstItemIndex = (this.currentpage-1) * this.pagesize+1;
			if (this.currentpage === this.pageCount) {
				this.lastItemIndex = this.itemCount;
			} else {
				this.lastItemIndex = (this.currentpage)* this.pagesize;
			}
		},
		changeDropDown: function(e) {
			var size = parseInt(e.target.value),
					index = this.sizelist.indexOf(size);
					console.log('index = ', index);
			var parentElem = this.getClosest(e.target, 'select'),
					optionList = Polymer.dom(parentElem).querySelectorAll("option");
					optionList.forEach(function(option) {
						if (parseInt(option.value) === parseInt(size)) {
							option.setAttribute('selected', '');
							e.target.selectedIndex = parseInt(index);
							console.log('e.target.selectedIndex = ', e.target.selectedIndex);
						} else {
							option.removeAttribute('selected');
						}
					});

			this.changeSize(size);
		},
		changeSize: function(size) {
			this.set('pagesize', size);
		},
		pagesizeChanged: function(newValue, oldValue){
			this.pagesize = parseInt(this.pagesize);
			this.refreshPagination();
		},
		_selectedRowsChanged: function(newValue, oldValue){
			if (Array.isArray(newValue) && (newValue.splices === void 0)){
				var sr = [];
				sr.splices = {};
				this.selectedRows = sr;
			}
		},
		// fallback default sort function if per-column sort isn't specified.
		_defaultSort: function(a, b) {
			return this.descending ? (a.value < b.value ? 1 : -1) : (a.value > b.value ? 1 : -1);
		},
		_searchableToggled: function(changeRecord){
			var _this = this,
					i,
					len,
					toggeldSerachable = Polymer.dom(this.root).querySelectorAll('.filter-input'),
					data = this.data;

			if(this.filtered){
				for (i = 0, len=toggeldSerachable.length; i<len; i++) {
					toggeldSerachable[i].value='';
				}

				for (i = 0, len=data.length; i<len; i++) {
					data[i]._filtered=false;
				}

				this.filtered = false;
				this.refreshPagination();
			}
		},
		// call this when total count is no changed.
		filterPage: function() {
			var from = (this.currentpage-1) * this.pagesize,
					to   = from + this.pagesize,
					_this = this,
					filteredRows = this.filtered ? this.data.filter(function(r){return !r._filtered;}) : this.data;

			if (this.sortedColumn) {
				//work out if customr sort function exists for sorted column.
				var sortFunction;
				this.meta.forEach(function(obj){
					if (this.sortedColumn === obj.name){
						sortFunction = this.customFunctions[obj['sort-function-name']];
					}
				}, this);

				if (!sortFunction) {
					sortFunction = this._defaultSort;
				}

				// sorting map: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Sorting_maps
				filteredRows =
				filteredRows
					.map(function(e, i){
						var v = e[this.sortedColumn];
						if (undefined === v || null === v) {
							v = '';
						}
						return {
							index: i,
							value: typeof v === "string" ? v.toLowerCase() : v
						};
					}, this)
					.sort(sortFunction.bind(this))
					.map(function(e){
						return filteredRows[e.index];
					});
			}

			this.set('viewingRows', filteredRows.slice(from, to));

			/* ugliest code i've written in a while.
			/* the setTimeout is here to ensure that polymer finishes its redraw.
			/* by using setTimeout, i'm taking this command out of scope, allowing the redraw to finish.
			/* yes. it's ugly. sorry.*/

			setTimeout(function() {
				if (_this.selectedRows && _this.selectedRows.length) {
					_this.findSelectedRows();
				}
			},0);

		},
		findSelectedRows: function() {
			var viewingRows = this.viewingRows,
					selectedRows = this.selectedRows,
					resultsArray = [],
					stringifiedViewedRowArray = [],
					stringifiedSelectedRowArray = [],
					result,
					state,
					index;

			stringifiedViewedRowArray = this.createStringifiedJSONArray(viewingRows);
			stringifiedSelectedRowArray = this.createStringifiedJSONArray(selectedRows);

			resultsArray = stringifiedViewedRowArray.map(function(row, i) {
				index = i; //set our index
				state = (stringifiedSelectedRowArray.indexOf(row) > -1) ? true : false; //find out the state
				return {"index": index, "state": state}; //and return the object
			});

			this.changeCheckboxState(resultsArray);
		},
		createStringifiedJSONArray: function(JSONArray) {
			var i,
					len,
					resultArray = [];
			for (i=0, len=JSONArray.length; i<len;i++) {
				resultArray.push(JSON.stringify(JSONArray[i]));
			}
			return resultArray;
		},
		changeCheckboxState: function(resultsArray) {
			if (this.selectedRows && this.selectedRows.length) {
				var checkboxNodeList = Polymer.dom(this.root).querySelectorAll('.js-table__select-checkbox');
				resultsArray.forEach(function(result) {
					checkboxNodeList[result.index].checked = result.state;
				});
			}
		},
		// call this when total count is change.
		refreshPagination: function(keepInTheCurrentPage) {
			if (!keepInTheCurrentPage) {
				// Usually go to the first page is the best way to avoid chaos.
				this.currentpage = 1;
			}

			// Cache the total page count and item count
			var count = 0;
			this.data.forEach(function(row) {
				if (!row._filtered) {
					count++;
				}
			});
			this.itemCount = count;
			this.pageCount = Math.ceil( count / this.pagesize );
			this.updateFirstAndLastDisplayedItemIndexes();

			// Update model bound to UI with filtered range
			this.filterPage();
		},


		//=======================//
		//data manipulation//
		click: function(e,p) {
			var column = e.model.column;
			var row = e.model.row;
			var detail = {"row" : row, "column" : column};
			this.select(e,p);
			this.fire('px-row-click', detail);
		},
		dbclick: function(e,p) {
			var column = e.model.column,
					row = e.model.row,
					detail = {"row" : row, "column" : column};
			this.fire('after-td-dbclick', detail);
		},
		select: function(e,p){
			if (this.selectable) {
				var row = e.model.row,
						selectAllCheckbox;
				this.fire('before-select', row);
				if (this.selectedRows.indexOf(row) > -1) {
					// the row is already selected, we'll remove it from the  selectedRows array.
					this.splice('selectedRows', this.selectedRows.indexOf(row), 1);
					this.set('_selected', false, row);
				} else {
					this.push('selectedRows', row);
					this.set('_selected', true, row);
				}

				if(e.target.type !== "checkbox") {
					var parentElem = this.getClosest(e.target, '.tr');
					Polymer.dom(parentElem).querySelector("input").checked = row._selected;
				}

				/* this is commented out since it disables the checkbox from being checked.
				/* leaving this here for when we add editing functionality */
				// if (!row._editing) {
				// 	e.preventDefault();
				// }

				selectAllCheckbox = Polymer.dom(this.root).querySelector("#filter");
				selectAllCheckbox.querySelector("input[type=checkbox]").checked = false;
				this.fire('after-select', row);
			}
		},
		create: function(obj) {
			this.fire('before-create', obj);
			var _default = {_editing: true, _modified: true},
					_new = obj instanceof Object ? obj : _default,
					len,
					i,
					meta = this.meta;

			for (i=0,len=meta.length;i<len;i++) {
				if (meta[i].default && _new[meta[i].name] === undefined) {
					_new[meta[i].name] = meta[i].default;
				}
			}

			this.splice('data',0,0,_new);
			this.splice('viewingRows',0,0,_new);
			this.push('modified', _new);
			this.fire('after-create', _new);
		},
		copy: function(e, detail, sender) {
			var obj = e.model.row,
					_new;

			this.fire('before-copy', obj);
			_new = JSON.parse(JSON.stringify(obj));
			if (_new.id) {
				delete _new.id;
			}
			_new._modified = true;
			_new._editing = false;

			this.splice('data',0,0,_new);
			this.splice('viewingRows',0,0,_new);
			this.push('modified', _new);
			this.fire('after-copy', _new);
		},
		remove: function(e, detail, sender) {
			var obj = e.model.row,
					found_index,
					found_index_in_modified;

			this.fire('before-remove', obj);
			found_index = this.data.indexOf(obj);
			if (found_index !== -1) {
				this.splice('data',found_index,1);
				this.splice('viewingRows',found_index,1);
				this.push('deleted', obj);
			}
			found_index_in_modified = this.modified.indexOf(obj);
			if (found_index_in_modified !== -1) {
				obj._modified = false;
				this.splice('modified',found_index_in_modified,1);
			}
			this.fire('after-remove', obj);
		},
		movedown: function(e) {
			var row = e.model.row;

			this.fire('before-move-down', row);

			if (this.sortedColumn) {
				this.unsort();
			}

			this._movedown('viewingRows', row);
			this._movedown('data', row);
			this.fire('after-move-down', row);
		},
		_movedown: function(setName, row) {
			var index = this.get(setName).indexOf(row),
					newPosition = index + 1;

			if (newPosition >= this.get(setName).length) {
				newPosition = this.get(setName).length;
			}

			this.splice(setName,index,1);
			this.splice(setName,newPosition,0,row);
		},
		moveup: function(e) {
			var row = e.model.row;

			this.fire('before-move-up', row);

			if (this.sortedColumn) {
				this.unsort();
			}

			this._moveup('viewingRows', row);
			this._moveup('data', row);
			this.fire('after-move-up', row);
		},
		_moveup: function(setName, row) {
			var index = this.get(setName).indexOf(row),
					newPosition = index - 1;

			if (newPosition < 0) {
				newPosition = 0;
			}

			this.splice(setName,index,1);
			this.splice(setName,newPosition,0,row);
		},
		toggleFilters: function(e) {
			e.target.classList.toggle('search');
			e.target.classList.toggle('nosearch');
			this.$$('#filter').classList.toggle('hide');
		},
		selectall: function(e,p){
			var _this = this,
					selectors = Polymer.dom(this.root).querySelectorAll('.js-table__select-checkbox'),
					selectedRows = this.selectedRows,
					data = this.data,
					len,
					i;
			if(e.target.checked) {
				for (i=0, len=selectedRows.length;i<len;i++) {
					_this.set('_selected', false, selectedRows[i]);
				}
				//to ensure we don't have any doubles, we empty out the array first
					_this.splice('selectedRows', 0, _this.selectedRows.length);
				//next, we add EVERYTHING into the selectedRows array, and use set to set the property and notify Polymer
				for (i = 0, len = data.length; i <len; i++) {
					_this.push('selectedRows', data[i]);
					_this.set('_selected', true, data[i]);
				}
				//lastly, we manually change the .checked property on the checkboxes.
				for (i = 0, len = selectors.length ; i < len; i++) {
					selectors[i].checked = true;
				}
			} else {
				//this will reset our selectedRows array
				_this.splice('selectedRows', 0, _this.selectedRows.length);

				//set _selected to false on each row
				for (i = 0, len = data.length; i <len; i++) {
					_this.set('_selected', false, data[i]);
				}
				//and unckeck our checkboxes
				for (i = 0, len = selectors.length; i < len; i++) {
					selectors[i].checked = false;
				}
			}
		},
		pagerButtons: function(pageCount, currentpage) {
			if (this.pageCount){
				var noOfPagerButtons = 0,
						pagerNavButtonsConfig=[],
						i;

				if (this.pageCount <= 9) {
					noOfPagerButtons = this.pageCount;
					pagerNavButtonsConfig = Array.apply(null, Array(noOfPagerButtons)).map(
						function (val, index) {
							return {val: index+1};
					});
				}
				else if (this.pageCount <= currentpage + 3 ) {
					noOfPagerButtons = 9;
					pagerNavButtonsConfig.push({val: 1});
					pagerNavButtonsConfig.push({val: '...'});

					for (i = this.pageCount - 6; i <= this.pageCount;i++){
						pagerNavButtonsConfig.push({val: i});
					}
				}
				else {
					noOfPagerButtons = 9;
					if (currentpage <= 5){
						pagerNavButtonsConfig = Array.apply(null, Array(7)).map(
							function (val, index) {
								return {val: index+1};
						});
						pagerNavButtonsConfig.push({val: '...'});
						pagerNavButtonsConfig.push({val: this.pageCount});
					}
					else {
						pagerNavButtonsConfig.push({val: 1});
						pagerNavButtonsConfig.push({val: '...'});
						for (i = currentpage - 3; i < currentpage+2;i++){
							pagerNavButtonsConfig.push({val: i});
						}
						pagerNavButtonsConfig.push({val: '...'});
						pagerNavButtonsConfig.push({val: this.pageCount});
					}
				}
				return pagerNavButtonsConfig;
			}
		},
		gotoPage: function(evt){
			this.currentpage = parseInt(evt.target.textContent);
		},
		getClosest: function(elem, selector) {
    var firstChar = selector.charAt(0);
    // Get closest match
    for ( ; elem && elem !== document; elem = elem.parentNode ) {
        // If selector is a class
        if ( firstChar === '.' ) {
            if ( elem.classList.contains( selector.substr(1) ) ) {
                return elem;
            }
        }
        // If selector is an ID
        if ( firstChar === '#' ) {
            if ( elem.id === selector.substr(1) ) {
                return elem;
            }
        }
        // If selector is a data attribute
        if ( firstChar === '[' ) {
            if ( elem.hasAttribute( selector.substr(1, selector.length - 2) ) ) {
                return elem;
            }
        }
        // If selector is a tag
        if ( elem.tagName.toLowerCase() === selector ) {
            return elem;
        }
    }
    return false;
}
	});
</script>

<!--
/**
 * @module aha-html-echo
 *
 *
 * Generates html elements dynamically, inspired by sortable-table
 * https://github.com/stevenrskelton/sortable-table
 *
 * WARNING! Potential XSS vulnerability if `html` comes from an untrusted source
 *
 *    <aha-html-echo
 *         html="html">
 *    </aha-html-echo>
 *
 * @class aha-html-echo
 * @author Michael Heinrichs<michael.heinrichs@canoo.com>
 *
 */
-->
<script>
    Polymer({
        is: "aha-html-echo",
        properties: {
            //column name
            html: {
                type: String,
                value: "",
                observer: "onHtmlChanged"
            }
        },
        onHtmlChanged: function() {
						if (!this.html){
							this.html = "";
						}
            this.innerHTML = this.html;
        }
    });
</script>
